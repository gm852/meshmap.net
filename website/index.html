<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="theme-color" content="#fff">
<meta name="description" content="A nearly live map of Meshtastic nodes seen by the official Meshtastic MQTT server">
<title>MeshMap - Meshtastic Node Map</title>
<link rel="preload" href="/nodes.json" as="fetch" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900">
<link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet-easybutton@2.4.0/src/easy-button.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet-search@4.0.0/dist/leaflet-search.min.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
<link rel="manifest" href="/site.webmanifest">
<style>
  html, body {
    height: 100%;
  }
  body {
    margin: 0;
    padding: 0;
  }
  body.dark {
    filter: invert(1) hue-rotate(180deg) brightness(1.33);
  }
  body.dark .dark-hidden {
    display: none;
  }
  body:not(.dark) .dark-only {
    display: none;
  }
  /* give seach and leaderboard dark mode */
  body.dark #search-container {
    filter: invert(1) hue-rotate(180deg) brightness(0.75);
  }
  body.dark #leaderboard-container {
    filter: invert(1) hue-rotate(180deg) brightness(0.75);
  }
  #header {
    background-color: #fff;
    box-shadow: 0 0 4px 0 rgb(0 0 0 / 40%);
    color: #333;
    display: flex;
    align-items: center;
    gap: 1em;
    font-family: "Inter", sans-serif;
    font-size: 16px;
    line-height: 1.2;
    height: 50px;
    padding: 0 17px 0 15px;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
  }
  #search-container {
    flex: 1;
    max-width: 500px;
    margin: 0 auto;
  }
  #search-input {
    width: 100%;
    padding: 8px 12px;
    border: 2px solid #ddd;
    border-radius: 20px;
    font-size: 14px;
    font-family: "Inter", sans-serif;
    outline: none;
    transition: border-color 0.2s;
  }
  #search-input:focus {
    border-color: #4a90e2;
  }
  #search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    width: 100%;
    max-width: 500px;
    margin-left: auto;
    margin-right: auto;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 12px;
    margin-top: 8px;
    max-height: 400px;
    overflow-y: auto;
    box-shadow: 0 8px 24px rgba(0,0,0,0.12), 0 2px 8px rgba(0,0,0,0.08);
    display: none;
    z-index: 1001;
    padding: 4px 0;
    opacity: 0;
    transform: translateY(-8px);
    transition: opacity 0.2s ease, transform 0.2s ease;
  }
  #search-results.show {
    display: block;
    opacity: 1;
    transform: translateY(0);
  }
  /* Custom scrollbar for search results */
  #search-results::-webkit-scrollbar {
    width: 8px;
  }
  #search-results::-webkit-scrollbar-track {
    background: #f5f5f5;
    border-radius: 4px;
  }
  #search-results::-webkit-scrollbar-thumb {
    background: #ccc;
    border-radius: 4px;
  }
  #search-results::-webkit-scrollbar-thumb:hover {
    background: #aaa;
  }
  .search-result-item {
    padding: 12px 16px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .search-result-item:hover {
    background-color: #f8f9fa;
    border-left: 3px solid #4a90e2;
    padding-left: 13px;
  }
  .search-result-item:last-child {
    border-bottom: none;
  }
  .search-result-item.no-results {
    cursor: default;
    padding: 20px;
    text-align: center;
    color: #999;
    justify-content: center;
  }
  .search-result-item.no-results:hover {
    background-color: white;
    border-left: none;
    padding-left: 20px;
  }
  .search-result-icon {
    width: 40px;
    height: 40px;
    border-radius: 8px;
    background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 600;
    font-size: 14px;
    flex-shrink: 0;
  }
  .search-result-content {
    flex: 1;
    min-width: 0;
  }
  .search-result-name {
    font-weight: 600;
    color: #1a1a1a;
    font-size: 14px;
    line-height: 1.4;
    margin-bottom: 4px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .search-result-meta {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: #666;
  }
  .search-result-id {
    font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
    color: #4a90e2;
    font-weight: 500;
  }
  .search-result-match {
    display: inline-flex;
    align-items: center;
    padding: 2px 6px;
    border-radius: 4px;
    background-color: #e8f4f8;
    color: #2c5f7d;
    font-size: 11px;
    font-weight: 500;
  }
  .search-result-divider {
    color: #ccc;
  }
  /* Dark mode support for search results */
  body.dark #search-results {
    background: #1a1a1a;
    border-color: #333;
  }
  body.dark .search-result-item {
    border-bottom-color: #2a2a2a;
  }
  body.dark .search-result-item:hover {
    background-color: #252525;
  }
  body.dark .search-result-item.no-results:hover {
    background-color: #1a1a1a;
  }
  body.dark .search-result-name {
    color: #e0e0e0;
  }
  body.dark .search-result-meta {
    color: #999;
  }
  body.dark .search-result-id {
    color: #6ba3e3;
  }
  body.dark .search-result-match {
    background-color: #2a3a4a;
    color: #8bb4d8;
  }
  body.dark .search-result-divider {
    color: #555;
  }
  body.dark #search-results::-webkit-scrollbar-track {
    background: #2a2a2a;
  }
  body.dark #search-results::-webkit-scrollbar-thumb {
    background: #555;
  }
  body.dark #search-results::-webkit-scrollbar-thumb:hover {
    background: #666;
  }
  #header a {
    color: inherit;
    text-decoration: none;
  }
  #header a:hover {
    opacity: 0.7;
  }
  #header a img {
    display: block;
  }
  #header div:nth-child(2) {
    flex-grow: 1;
  }
  /* Leaderboard styles */
  #leaderboard-container {
    position: relative;
  }
  #leaderboard-button {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    border: 1px solid #ddd;
    border-radius: 6px;
    background: white;
    cursor: pointer;
    font-size: 13px;
    color: #333;
    transition: all 0.2s;
    white-space: nowrap;
  }
  #leaderboard-button:hover {
    background: #f5f5f5;
    border-color: #bbb;
  }
  #leaderboard-button i {
    font-size: 14px;
  }
  #leaderboard-dropdown {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 8px;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.12), 0 2px 8px rgba(0,0,0,0.08);
    min-width: 280px;
    max-width: 350px;
    max-height: 500px;
    overflow-y: auto;
    display: none;
    z-index: 1002;
    padding: 8px 0;
  }
  #leaderboard-dropdown.show {
    display: block;
  }
  .leaderboard-header {
    padding: 12px 16px;
    border-bottom: 1px solid #f0f0f0;
    font-weight: 600;
    font-size: 14px;
    color: #333;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .leaderboard-item {
    padding: 10px 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: pointer;
    transition: background-color 0.15s;
    border-bottom: 1px solid #f8f8f8;
  }
  .leaderboard-item:hover {
    background-color: #f8f9fa;
  }
  .leaderboard-item:last-child {
    border-bottom: none;
  }
  .leaderboard-rank {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 12px;
    flex-shrink: 0;
  }
  .leaderboard-rank.top-1 {
    background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
    color: #8b6914;
  }
  .leaderboard-rank.top-2 {
    background: linear-gradient(135deg, #c0c0c0 0%, #e8e8e8 100%);
    color: #5a5a5a;
  }
  .leaderboard-rank.top-3 {
    background: linear-gradient(135deg, #cd7f32 0%, #e6a055 100%);
    color: #6b4a1a;
  }
  .leaderboard-rank.other {
    background: #f0f0f0;
    color: #666;
  }
  .leaderboard-info {
    flex: 1;
    min-width: 0;
  }
  .leaderboard-name {
    font-weight: 600;
    font-size: 13px;
    color: #1a1a1a;
    margin-bottom: 2px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .leaderboard-stats {
    font-size: 11px;
    color: #666;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .leaderboard-stat {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .leaderboard-stat i {
    font-size: 10px;
  }
  /* Dark mode for leaderboard */
  body.dark #leaderboard-button {
    background: #2a2a2a;
    border-color: #444;
    color: #e0e0e0;
  }
  body.dark #leaderboard-button:hover {
    background: #333;
    border-color: #555;
  }
  body.dark #leaderboard-dropdown {
    background: #1a1a1a;
    border-color: #333;
  }
  body.dark .leaderboard-header {
    border-bottom-color: #2a2a2a;
    color: #e0e0e0;
  }
  body.dark .leaderboard-item {
    border-bottom-color: #2a2a2a;
  }
  body.dark .leaderboard-item:hover {
    background-color: #252525;
  }
  body.dark .leaderboard-name {
    color: #e0e0e0;
  }
  body.dark .leaderboard-stats {
    color: #999;
  }
  body.dark .leaderboard-rank.other {
    background: #333;
    color: #999;
  }
  /* Leaderboard scrollbar */
  #leaderboard-dropdown::-webkit-scrollbar {
    width: 8px;
  }
  #leaderboard-dropdown::-webkit-scrollbar-track {
    background: #f5f5f5;
    border-radius: 4px;
  }
  #leaderboard-dropdown::-webkit-scrollbar-thumb {
    background: #ccc;
    border-radius: 4px;
  }
  #leaderboard-dropdown::-webkit-scrollbar-thumb:hover {
    background: #aaa;
  }
  body.dark #leaderboard-dropdown::-webkit-scrollbar-track {
    background: #2a2a2a;
  }
  body.dark #leaderboard-dropdown::-webkit-scrollbar-thumb {
    background: #555;
  }
  body.dark #leaderboard-dropdown::-webkit-scrollbar-thumb:hover {
    background: #666;
  }
  #map {
    position: absolute;
    top: 50px;
    bottom: 0;
    left: 0;
    right: 0;
  }
  table {
    border-collapse: collapse;
  }
  table :is(th, td) {
    text-align: left;
    vertical-align: top;
  }
  table :is(th, td):nth-child(n+2) {
    padding-left: 1em;
  }
  .break {
    word-break: break-all;
  }
  .leaflet-tooltip, .leaflet-popup-content {
    font-family: "Inter", sans-serif;
    font-size: 12px;
  }
  .leaflet-popup-content .title {
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 3px;
  }
  .leaflet-popup-content table {
    margin-top: 1em;
  }
  .popup-tabs {
    display: flex;
    border-bottom: 2px solid #eee;
    margin: 10px 0;
  }
  .popup-tab {
    flex: 1;
    padding: 8px 12px;
    text-align: center;
    cursor: pointer;
    border: none;
    background: none;
    font-family: "Inter", sans-serif;
    font-size: 13px;
    color: #666;
    transition: all 0.2s;
  }
  .popup-tab:hover {
    background-color: #f5f5f5;
  }
  .popup-tab.active {
    color: #4a90e2;
    border-bottom: 2px solid #4a90e2;
    font-weight: 600;
  }
  .popup-tab-content {
    display: none;
    max-height: 400px;
    overflow-y: auto;
  }
  .popup-tab-content.active {
    display: block;
  }
  .message-item {
    padding: 10px;
    border-bottom: 1px solid #eee;
    font-size: 13px;
  }
  .message-item:last-child {
    border-bottom: none;
  }
  .message-text {
    color: #333;
    margin-bottom: 4px;
    word-wrap: break-word;
  }
  .message-time {
    font-size: 11px;
    color: #999;
  }
  .no-messages {
    padding: 20px;
    text-align: center;
    color: #999;
    font-size: 13px;
  }
  .leaflet-right .leaflet-control-attribution {
    text-align: right;
  }
  body.dark .leaflet-shadow-pane {
    display: none;
  }
  body.dark :is(.leaflet-tooltip, .leaflet-popup-content-wrapper, .leaflet-popup-tip) {
    box-shadow: 0 0 4px 0 rgb(0 0 0 / 40%);
  }
  @media (hover: none) {
    .leaflet-tooltip-pane {
      display: none;
    }
  }
</style>
<script>
  const toggleDark = () => {
    if (document.body.classList.toggle('dark')) {
      document.querySelector('meta[name="theme-color"]').content = '#000'
      window.localStorage.setItem('theme', 'dark')
      return true
    }
    document.querySelector('meta[name="theme-color"]').content = '#fff'
    window.localStorage.removeItem('theme')
    return false
  }
  if (window.localStorage.getItem('theme') === 'dark') {
    document.addEventListener('DOMContentLoaded', () => toggleDark())
  }
</script>
<div id="header">
  <div>
    <a href="https://meshmap.net/" title="A nearly live map of Meshtastic nodes seen by the official Meshtastic MQTT server">MeshMap</a>
  </div>
  <div id="search-container">
    <input type="text" id="search-input" placeholder="Search nodes by name or ID (e.g., !a1b2c3d4)..." autocomplete="off">
    <div id="search-results"></div>
  </div>
  <div id="leaderboard-container">
    <div id="leaderboard-button" onclick="toggleLeaderboard()">
      <i class="fa fa-trophy"></i>
      <span>Top Nodes</span>
    </div>
    <div id="leaderboard-dropdown"></div>
  </div>
  <div>
    <a href="#" onclick="toggleDark();return false;" title="Toggle dark mode">
      <i class="fa fa-moon-o fa-lg dark-hidden"></i>
      <i class="fa fa-sun-o fa-lg dark-only"></i>
    </a>
  </div>
  <div>
    <a href="https://github.com/brianshea2/meshmap.net?tab=readme-ov-file#faqs" title="FAQs"><i class="fa fa-question-circle fa-lg"></i></a>
  </div>
  <div>
    <a href="https://github.com/brianshea2/meshmap.net" title="GitHub"><i class="fa fa-github fa-lg"></i></a>
  </div>
  <div>
    <a href="https://meshtastic.org/" title="Powered by Meshtastic">
      <img alt="Meshtastic" src="/m-pwrd_bw_noborder-min.svg" style="width:1.2em;height:1.2em;">
    </a>
  </div>
</div>
<div id="map"></div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-easybutton@2.4.0/src/easy-button.js"></script>
<script src="https://unpkg.com/leaflet-search@4.0.0/dist/leaflet-search.min.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script>
  let lastActiveNode
  let markersByNode = {}
  let nodesBySearchString = {}
  const ipinfoToken = 'aeb066758afd49'
  const updateInterval = 65000
  const precisionMargins = [
    11939464, 5969732, 2984866, 1492433, 746217, 373108, 186554, 93277,
    46639, 23319, 11660, 5830, 2915, 1457, 729, 364,
    182, 91, 46, 23, 11, 6, 3, 1,
    1, 0, 0, 0, 0, 0, 0, 0
  ]
  // encodes html reserved characters and ascii control characters
  const html = str => str
    ?.replace(/[\x00-\x1F]/g, c => `\\x${c.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0')}`)
    .replace(/["&<>]/g, c => `&#${c.charCodeAt(0)};`)
  // makes more human-readable time duration strings
  const duration = d => {
    let s = ''
    if (d > 86400) {
      s += `${Math.floor(d / 86400)}d `
      d %= 86400
    }
    if (d > 3600) {
      s += `${Math.floor(d / 3600)}h `
      d %= 3600
    }
    s += `${Math.floor(d / 60)}min`
    return s
  }
  const since = t => `${duration(Date.now() / 1000 - t)} ago`
  // init map
  const map = L.map('map', {
    center: window.localStorage.getItem('center')?.split(',') ?? [25, 0],
    zoom: window.localStorage.getItem('zoom') ?? 2,
    attributionControl: false,
    zoomControl: false,
    worldCopyJump: true,
  })
  // add tiles
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Map tiles from <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
    maxZoom: 17,
  }).addTo(map)
  // add marker group
  const markers = L.markerClusterGroup({
    maxClusterRadius: zoom => zoom < 3 ? 40 : 30,
  }).addTo(map)
  // add node details layer (precision circle, relation lines)
  const detailsLayer = L.layerGroup().addTo(map)
  map.on('click', () => detailsLayer.clearLayers())
  let allNodesData = {}
  const searchInput = document.getElementById('search-input')
  const searchResults = document.getElementById('search-results')
  
  const performSearch = (query) => {
    if (!query || query.trim().length === 0) {
      searchResults.classList.remove('show')
      return
    }
    
    const q = query.toLowerCase().trim()
    const results = []
    
    // search by node ID
    if (q.startsWith('!')) {
      try {
        const nodeNum = parseInt(q.slice(1), 16)
        if (allNodesData[nodeNum]) {
          const node = allNodesData[nodeNum]
          const id = `!${Number(nodeNum).toString(16)}`
          results.push({
            nodeNum,
            name: node.longName || 'Unknown',
            shortName: node.shortName || '',
            id,
            match: 'ID'
          })
        }
      } catch (e) {
        console.error('Invalid hex:', e)
      }
    }
    
    // Search by name
    Object.entries(allNodesData).forEach(([nodeNum, node]) => {
      const longName = (node.longName || '').toLowerCase()
      const shortName = (node.shortName || '').toLowerCase()
      const id = `!${Number(nodeNum).toString(16)}`.toLowerCase()
      
      if (longName.includes(q) || shortName.includes(q) || id.includes(q)) {
        if (!results.find(r => r.nodeNum === Number(nodeNum))) {
          results.push({
            nodeNum: Number(nodeNum),
            name: node.longName || 'Unknown',
            shortName: node.shortName || '',
            id: `!${Number(nodeNum).toString(16)}`,
            match: longName.includes(q) ? 'Name' : shortName.includes(q) ? 'Short Name' : 'ID'
          })
        }
      }
    })
    
    // show results
    if (results.length > 0) {
      const displayResults = results.slice(0, 10)
      const hasMore = results.length > 10
      searchResults.innerHTML = displayResults.map(r => {
        const initials = (r.shortName || r.name || '?').substring(0, 2).toUpperCase()
        return `
        <div class="search-result-item" onclick="selectSearchResult(${r.nodeNum})">
          <div class="search-result-icon">${html(initials)}</div>
          <div class="search-result-content">
            <div class="search-result-name">${html(r.name)}${r.shortName ? ` <span style="color:#888;font-weight:400;">(${html(r.shortName)})</span>` : ''}</div>
            <div class="search-result-meta">
              <span class="search-result-id">${r.id}</span>
              <span class="search-result-divider">•</span>
              <span class="search-result-match">${r.match}</span>
            </div>
          </div>
        </div>
      `}).join('') + (hasMore ? `<div class="search-result-item no-results" style="font-size:12px;padding:8px 16px;"><i class="fa fa-info-circle" style="margin-right:6px;"></i>Showing 10 of ${results.length} results</div>` : '')
      searchResults.classList.add('show')
    } else {
      searchResults.innerHTML = '<div class="search-result-item no-results"><i class="fa fa-search" style="margin-right:8px;"></i>No nodes found</div>'
      searchResults.classList.add('show')
    }
  }
  
  window.selectSearchResult = function(nodeNum) {
    searchResults.classList.remove('show')
    searchInput.value = ''
    showNode(nodeNum)
  }
  
  searchInput.addEventListener('input', (e) => {
    performSearch(e.target.value)
  })
  
  searchInput.addEventListener('focus', () => {
    if (searchInput.value.trim().length > 0) {
      performSearch(searchInput.value)
    }
  })
  
  // Close search results when clicking outside
  document.addEventListener('click', (e) => {
    if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
      searchResults.classList.remove('show')
    }
  })
  // add zoom control
  L.control.zoom({position: 'topright'}).addTo(map)
  // add geolocation control
  L.easyButton({
    position: 'topright',
    states: [
      {
        stateName: 'geolocation-button',
        title: 'Center map to current IP geolocation',
        icon: 'fa-crosshairs fa-lg',
        onClick: () => {
          fetch(`https://ipinfo.io/json?token=${ipinfoToken}`)
            .then(r => r.json())
            .then(({loc}) => loc && map.flyTo(loc.split(','), 10))
            .catch(e => console.error('Failed to set location:', e))
        },
      },
    ],
  }).addTo(map)
  // add attribution control
  const attribution = L.control.attribution({position: 'bottomright', prefix: false}).addTo(map)
  // updates attribution with given count of nodes
  const updateNodeCount = count => attribution.setPrefix(`
    ${count.toLocaleString()} nodes from
    <a href="https://meshtastic.org/docs/software/integrations/mqtt/#public-mqtt-server">Meshtastic MQTT</a>
  `)
  // track and store map position
  map.on('moveend', () => {
    const center = map.getCenter()
    window.localStorage.setItem('center', [center.lat, center.lng].join(','))
  })
  map.on('zoomend', () => {
    window.localStorage.setItem('zoom', map.getZoom())
  })
  // generates html for a node link
  const nodeLink = (num, label) => `<a href="#${num}" onclick="showNode(${num});return false;">${html(label)}</a>`
  // Tab switching (must be global for onclick)
  window.switchTab = function(button, tabName) {
    const popup = button.closest('.leaflet-popup-content')
    popup.querySelectorAll('.popup-tab').forEach(t => t.classList.remove('active'))
    popup.querySelectorAll('.popup-tab-content').forEach(c => c.classList.remove('active'))
    button.classList.add('active')
    popup.querySelector(`#tab-${tabName}`).classList.add('active')
  }
  // leaderboard
  const leaderboardDropdown = document.getElementById('leaderboard-dropdown')
  let leaderboardOpen = false
  
  window.toggleLeaderboard = function() {
    leaderboardOpen = !leaderboardOpen
    if (leaderboardOpen) {
      updateLeaderboard()
      leaderboardDropdown.classList.add('show')
    } else {
      leaderboardDropdown.classList.remove('show')
    }
  }
  
  // Close leaderboard when clicking outside
  document.addEventListener('click', (e) => {
    const container = document.getElementById('leaderboard-container')
    if (container && !container.contains(e.target) && leaderboardOpen) {
      leaderboardOpen = false
      leaderboardDropdown.classList.remove('show')
    }
  })
  
  const updateLeaderboard = () => {
    if (!allNodesData || Object.keys(allNodesData).length === 0) {
      leaderboardDropdown.innerHTML = '<div class="leaderboard-header"><i class="fa fa-info-circle"></i> No data available</div>'
      return
    }
    
    // Calculate activity score for each node
    const now = Date.now() / 1000
    const leaderboard = Object.entries(allNodesData)
      .map(([nodeNum, node]) => {
        const messageCount = (node.messages || []).length
        const lastSeen = Math.max(...Object.values(node.seenBy || {}), 0)
        const timeSinceLastSeen = now - lastSeen
        // Activity score: message count * 10 + (recent activity bonus)
        // Recent activity = higher score for nodes seen in last hour
        const recentActivityBonus = timeSinceLastSeen < 3600 ? 50 : Math.max(0, 100 - timeSinceLastSeen / 60)
        const activityScore = messageCount * 10 + recentActivityBonus
        
        return {
          nodeNum: Number(nodeNum),
          name: node.longName || 'Unknown',
          shortName: node.shortName || '',
          id: `!${Number(nodeNum).toString(16)}`,
          messageCount,
          lastSeen,
          activityScore
        }
      })
      .filter(node => node.messageCount > 0 || node.lastSeen > 0) // Only show nodes with some activity
      .sort((a, b) => {
        // Sort by activity score, then by message count, then by last seen
        if (b.activityScore !== a.activityScore) {
          return b.activityScore - a.activityScore
        }
        if (b.messageCount !== a.messageCount) {
          return b.messageCount - a.messageCount
        }
        return b.lastSeen - a.lastSeen
      })
      .slice(0, 10) // Top 10
    
    if (leaderboard.length === 0) {
      leaderboardDropdown.innerHTML = '<div class="leaderboard-header"><i class="fa fa-info-circle"></i> No active nodes</div>'
      return
    }
    
    leaderboardDropdown.innerHTML = `
      <div class="leaderboard-header">
        <i class="fa fa-trophy"></i>
        Most Active Nodes
      </div>
      ${leaderboard.map((node, index) => {
        const rank = index + 1
        const rankClass = rank === 1 ? 'top-1' : rank === 2 ? 'top-2' : rank === 3 ? 'top-3' : 'other'
        return `
          <div class="leaderboard-item" onclick="selectLeaderboardNode(${node.nodeNum})">
            <div class="leaderboard-rank ${rankClass}">${rank}</div>
            <div class="leaderboard-info">
              <div class="leaderboard-name">${html(node.name)}${node.shortName ? ` <span style="color:#888;font-weight:400;">(${html(node.shortName)})</span>` : ''}</div>
              <div class="leaderboard-stats">
                <span class="leaderboard-stat">
                  <i class="fa fa-comment"></i>
                  ${node.messageCount} ${node.messageCount === 1 ? 'message' : 'messages'}
                </span>
                <span class="leaderboard-stat">
                  <i class="fa fa-clock-o"></i>
                  ${since(node.lastSeen)}
                </span>
              </div>
            </div>
          </div>
        `
      }).join('')}
    `
  }
  
  window.selectLeaderboardNode = function(nodeNum) {
    leaderboardOpen = false
    leaderboardDropdown.classList.remove('show')
    showNode(nodeNum)
  }
  
  // updates node map markers
  const updateNodes = data => {
    allNodesData = data
    // Update leaderboard if it's open
    if (leaderboardOpen) {
      updateLeaderboard()
    }
    const popupWasOpen = lastActiveNode && markersByNode[lastActiveNode]?.isPopupOpen()
    const detailsLayerWasPopulated = detailsLayer.getLayers().length > 0
    markersByNode = {}
    nodesBySearchString = {}
    markers.clearLayers()
    detailsLayer.clearLayers()
    let reactivate = () => {}
    const relationsByNode = {}
    Object.entries(data).forEach(([nodeNum, node]) => {
      const {
        longName, shortName, hwModel, role,
        fwVersion, region, modemPreset, hasDefaultCh, onlineLocalNodes,
        latitude, longitude, altitude, precision,
        batteryLevel, voltage, chUtil, airUtilTx, uptime,
        temperature, relativeHumidity, barometricPressure, lux,
        windDirection, windSpeed, windGust, radiation, rainfall1, rainfall24,
        neighbors, seenBy
      } = node
      const id = `!${Number(nodeNum).toString(16)}`
      const position = L.latLng([latitude, longitude].map(x => x / 10000000))
      const seenByNums = new Set(
        Object.keys(seenBy)
          .map(topic => topic.match(/\/!([0-9a-f]+)$/))
          .filter(match => match)
          .map(match => parseInt(match[1], 16))
      )
      relationsByNode[nodeNum] ??= {}
      seenByNums.forEach(seenByNum => {
        relationsByNode[seenByNum] ??= {}
        const relationObj = relationsByNode[nodeNum][seenByNum] ?? relationsByNode[seenByNum][nodeNum] ?? {}
        relationsByNode[nodeNum][seenByNum] = relationObj
        relationsByNode[seenByNum][nodeNum] = relationObj
        relationObj.mqtt = true
      })
      if (neighbors) {
        Object.keys(neighbors).forEach(neighborNum => {
          relationsByNode[neighborNum] ??= {}
          const relationObj = relationsByNode[nodeNum][neighborNum] ?? relationsByNode[neighborNum][nodeNum] ?? {}
          relationsByNode[nodeNum][neighborNum] = relationObj
          relationsByNode[neighborNum][nodeNum] = relationObj
          relationObj.neighbor = true
        })
      }
      const drawNodeDetails = () => {
        detailsLayer.clearLayers()
        // precision circle
        if (precision && precisionMargins[precision-1]) {
          L.circle(position, {radius: precisionMargins[precision-1], color: '#ffa932'}).addTo(detailsLayer)
        }
        // relation lines
        Object.entries(relationsByNode[nodeNum]).forEach(([relatedNum, relationObj]) => {
          if (data[relatedNum] === undefined) {
            return
          }
          const relatedPosition = L.latLng([data[relatedNum].latitude, data[relatedNum].longitude].map(x => x / 10000000))
          const relationContent = `
            <table><tbody>
            <tr><th>Nodes</th><td>${nodeLink(nodeNum, id)}, ${nodeLink(relatedNum, `!${Number(relatedNum).toString(16)}`)}</td></tr>
            <tr><th>Relation type</th><td>${[relationObj.neighbor && 'Neighbor', relationObj.mqtt && 'MQTT uplink'].filter(v => v).join(', ')}</td></tr>
            <tr><th>Distance</th><td>${Math.round(map.distance(position, relatedPosition)).toLocaleString()} m</td></tr>
            ${neighbors?.[relatedNum]?.snr ? `<tr><th>SNR</th><td>${neighbors[relatedNum].snr} dB</td></tr>` : ''}
            </tbody></table>
          `
          L.polyline([position, relatedPosition])
            .bindTooltip(relationContent, {opacity: 0.95, sticky: true})
            .on('click', () => showNode(relatedNum))
            .addTo(detailsLayer)
        })
      }
      const lastSeen = Math.max(...Object.values(seenBy))
      const opacity = 1.0 - (Date.now() / 1000 - lastSeen) / 129600
      const tooltipContent = `${html(longName)} (${html(shortName)}) ${since(lastSeen)}`
      
      // Messages section
      const messages = node.messages || []
      const messagesHtml = messages.length > 0
        ? messages.slice().reverse().map(msg => `
            <div class="message-item">
              <div class="message-text">${html(msg.text)}</div>
              <div class="message-time">${since(msg.timestamp)}</div>
            </div>
          `).join('')
        : '<div class="no-messages">No messages available</div>'
      
      const popupContent = `
        <div class="title">${html(longName)} (${html(shortName)})</div>
        <div>${nodeLink(nodeNum, id)} | ${html(role)} | ${html(hwModel)}</div>
        <div class="popup-tabs">
          <button class="popup-tab active" onclick="switchTab(this, 'info-${nodeNum}')">Info</button>
          <button class="popup-tab" onclick="switchTab(this, 'messages-${nodeNum}')">Messages ${messages.length > 0 ? `(${messages.length})` : ''}</button>
        </div>
        <div id="tab-info-${nodeNum}" class="popup-tab-content active">
        <table><tbody>
        ${uptime             ? `<tr><th>Uptime</th><td>${duration(uptime)}</td></tr>`                                : ''}
        ${batteryLevel       ? `<tr><th>Power</th><td>${batteryLevel > 100 ? 'Plugged in' : `${batteryLevel}%`}` +
                               `${voltage ? ` (${voltage.toFixed(2)}V)` : ''}</td></tr>`                             : ''}
        ${fwVersion          ? `<tr><th>Firmware</th><td>${html(fwVersion)}</td></tr>`                               : ''}
        ${region             ? `<tr><th>LoRa config</th><td>${html(region)} / ${html(modemPreset)}</td></tr>`        : ''}
        ${chUtil             ? `<tr><th>ChUtil</th><td>${chUtil.toFixed(2)}%</td></tr>`                              : ''}
        ${airUtilTx          ? `<tr><th>AirUtilTX</th><td>${airUtilTx.toFixed(2)}%</td></tr>`                        : ''}
        ${onlineLocalNodes   ? `<tr><th>Local nodes</th><td>${onlineLocalNodes}</td></tr>`                           : ''}
        ${precision && precisionMargins[precision-1] ? `<tr><th>Map privacy</th><td>` +
                               `&#177;${precisionMargins[precision-1].toLocaleString()} m (orange circle)</td></tr>` : ''}
        ${altitude           ? `<tr><th>Altitude</th><td>${altitude.toLocaleString()} m above MSL</td></tr>`         : ''}
        ${temperature        ? `<tr><th>Temperature</th><td>${temperature.toFixed(1)}&#8451; / ` +
                               `${(temperature * 1.8 + 32).toFixed(1)}&#8457;</td></tr>`                             : ''}
        ${relativeHumidity   ? `<tr><th>Relative humidity</th><td>${Math.round(relativeHumidity)}%</td></tr>`        : ''}
        ${barometricPressure ? `<tr><th>Barometric pressure</th><td>${Math.round(barometricPressure)} hPa</td></tr>` : ''}
        ${windDirection || windSpeed ? `<tr><th>Wind</th><td>` +
                                (windDirection ? `${windDirection}&#176;` : '') +
                                (windDirection && windSpeed ? ' @ ' : '') +
                                (windSpeed ? `${(windSpeed * 3.6).toFixed(1)}` : '') +
                                (windSpeed && windGust ? ` G ${(windGust * 3.6).toFixed(1)}` : '') +
                                (windSpeed ? ' km/h' : '') +
                                `</td></tr>`                                                                         : ''}
        ${lux                ? `<tr><th>Lux</th><td>${Math.round(lux)} lx</td></tr>`                                 : ''}
        ${radiation          ? `<tr><th>Radiation</th><td>${radiation.toFixed(2)} µR/h</td></tr>`                    : ''}
        ${rainfall1 || rainfall24 ? `<tr><th>Rainfall</th><td>` +
                                (rainfall1 ? `${rainfall1.toFixed(2)} mm/h` : '') +
                                (rainfall1 && rainfall24 ? ', ' : '') +
                                (rainfall24 ? `${rainfall24.toFixed(2)} mm/24h` : '') +
                                `</td></tr>`                                                                         : ''}
        </tbody></table>
        <table><thead>
        <tr><th>Last seen</th><th>via</th><th>MQTT root</th><th>channel</th></tr>
        </thead><tbody>
        ${Array.from(
          new Map(
            Object.entries(seenBy)
              .map(([topic, seen]) => (match => ({seen, via: match[3] ?? id, root: match[1], chan: match[2]}))(
                topic.match(/^(.*)(?:\/2\/e\/(.*)\/(![0-9a-f]+)|\/2\/map\/)$/s)
              ))
              .sort((a, b) => a.seen - b.seen)
              .map(v => [v.via, v])
          ).values(),
          ({seen, via, root, chan}) => `
            <tr>
            <td>${since(seen)}</td>
            <td>${chan ? ((n, l) => data[n] ? nodeLink(n, l) : l)(parseInt(via.slice(1), 16), via === id ? 'self' : via) : 'MapReport'}</td>
            <td class="break">${html(root)}</td>
            <td class="break">${html(chan ?? 'n/a')}</td>
            </tr>
          `
        ).reverse().join('')}
        </tbody></table>
        </div>
        <div id="tab-messages-${nodeNum}" class="popup-tab-content">
          <div style="max-height: 300px; overflow-y: auto;">
            ${messagesHtml}
          </div>
        </div>
      `
      const searchString = `${longName} (${shortName}) ${id}`
      nodesBySearchString[searchString] = nodeNum
      markersByNode[nodeNum] = L.marker(position, {alt: 'Node', opacity, searchString})
        .bindTooltip(tooltipContent, {opacity: 0.95})
        .bindPopup(popupContent, {maxWidth: 600})
        .on('popupopen', () => {
          // set last active
          lastActiveNode = nodeNum
          // set URL fragment
          history.replaceState(null, '', `#${nodeNum}`)
          // draw precision circle, relation lines
          drawNodeDetails()
        })
      if (nodeNum === lastActiveNode) {
        if (popupWasOpen) {
          reactivate = () => {
            const cluster = markers.getVisibleParent(markersByNode[nodeNum])
            if (typeof cluster?.spiderfy === 'function') {
              cluster.spiderfy()
            }
            markersByNode[nodeNum].openPopup()
          }
        } else if (detailsLayerWasPopulated) {
          reactivate = drawNodeDetails
        }
      }
    })
    markers.addLayers(Object.values(markersByNode))
    reactivate()
  }
  // fetches node data, updates map, repeats
  const drawMap = async () => {
    try {
      await fetch('/nodes.json').then(r => r.json()).then(updateNodes)
      updateNodeCount(Object.keys(markersByNode).length)
    } catch (e) {
      console.error('Failed to update nodes:', e)
    }
    setTimeout(() => {
      if (document.hidden) {
        document.addEventListener('visibilitychange', drawMap, {once: true})
      } else {
        drawMap()
      }
    }, updateInterval)
  }
  // pans and zooms map to node and opens popup
  const showNode = nodeNum => {
    if (markersByNode[nodeNum] === undefined) {
      return false
    }
    map.panTo(markersByNode[nodeNum].getLatLng())
    setTimeout(() => {
      markers.zoomToShowLayer(markersByNode[nodeNum], () => {
        markersByNode[nodeNum].openPopup()
      })
    }, 300)
    return true
  }
  // keep URL fragment in sync
  window.addEventListener('hashchange', () => {
    if (window.location.hash && !showNode(window.location.hash.slice(1))) {
      history.replaceState(null, '', window.location.pathname)
    }
    if (!window.location.hash) {
      map.closePopup()
      detailsLayer.clearLayers()
    }
  })
  map.on('popupclose', () => {
    if (window.location.hash) {
      history.replaceState(null, '', window.location.pathname)
    }
  })
  // let's go!!!
  attribution.setPrefix('Loading node data&hellip;')
  drawMap().then(() => {
    if (window.location.hash && !showNode(window.location.hash.slice(1))) {
      history.replaceState(null, '', window.location.pathname)
    }
  })
</script>
